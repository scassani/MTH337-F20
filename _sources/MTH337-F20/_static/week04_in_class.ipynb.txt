{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Week 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def myfun(mylist): # returns the product of second and last element of the list\n",
    "    return mylist[1]*mylist[-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myfun([2,3,4,5,6])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def myfun(mylist): # returns the product of second and last element of the list\n",
    "    a = mylist[1]*mylist[-1]\n",
    "    return a"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[3, 5]\n"
     ]
    }
   ],
   "source": [
    "mylist=[[1,2,11],[3,4,7],[5,6,13]]\n",
    "\n",
    "# want to get [3,5]\n",
    "\n",
    "print([mylist[1][0],mylist[2][0]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mutable and non-mutable"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 2, 3] [1, 2, 3]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=[1,2,3]\n",
    "b=a\n",
    "print(a,b)\n",
    "a is b # `is` will check if two variables have the same address"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4, 2, 3] [4, 2, 3]\n"
     ]
    }
   ],
   "source": [
    "b[0]=4\n",
    "print(a,b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "3 4\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=3\n",
    "b=a\n",
    "# print(a is b)\n",
    "b=4\n",
    "print(a,b)\n",
    "a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**mutable** objects (e.g. lists) can be modified without changing their address.\n",
    "\n",
    "**non-mutable** object (e.g. int,float,strings,booleans,tuples) are copied to a new address when modified"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Tuples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 2)\n"
     ]
    }
   ],
   "source": [
    "a=(1,2)\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "'tuple' object does not support item assignment",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-18-7845043af3cc>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0ma\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m22\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m: 'tuple' object does not support item assignment"
     ]
    }
   ],
   "source": [
    "a[0]=22"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**note** tuples can be returned by functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def myfun(mylist): # return first and last element of `mylist`\n",
    "    return mylist[0],mylist[-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a e\n"
     ]
    }
   ],
   "source": [
    "a,b=myfun(['a','b','c','d','e'])\n",
    "print(a,b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**note** to make a copy of a list, we can either slice or use the `copy()` method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[75, 2, 3] [75, 2, 3] [1, 2, 3] [1, 2, 3]\n"
     ]
    }
   ],
   "source": [
    "a=[1,2,3]\n",
    "b=a # not a separate copy\n",
    "c=a.copy() # copy\n",
    "d=a[:] # copy by slicing\n",
    "a[0]=75\n",
    "print(a,b,c,d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## More on functions: positional, keyword, default argument"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Define a function `cvol` that computes the volume of a cylinder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "from math import pi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cvol(r,h): # radius and height\n",
    "    return pi*r*r*h"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "37.69911184307752"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol(2,3) # argument by position"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56.548667764616276"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol(3,2) # argument by position"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56.548667764616276"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol(r=3,h=2) # argument by keyword - the order does not matter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56.548667764616276"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol(h=2,r=3) # argument by keyword"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cvol2(r,h=3):\n",
    "    return pi*r*r*h"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "37.69911184307752"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol2(2) # calling h=3 by default"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56.548667764616276"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cvol2(3,2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "def f(a,b,c):\n",
    "    return (a**b)/c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.4"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "f(2,c=5,b=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**note** arguments without a default value must go before the ones with a default value"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Ex.** build a function `change_n(mystr,n)` that changes the n-th entry of the string `mystr` to `'a'`, or return the original string if too short. If called with only the string argument, it should change the second character to `'a'`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For example `change_n('force')` --> 'farce'\n",
    "\n",
    "`change_n('force',5)` --> 'forca'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['f', 'o', 'r', 'c', 'e']\n"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "'str' object does not support item assignment",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-41-bdc8d825285f>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mmystr\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'force'\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mlist\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmystr\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m \u001b[0mmystr\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'a'\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m: 'str' object does not support item assignment"
     ]
    }
   ],
   "source": [
    "mystr='force'\n",
    "print(list(mystr))\n",
    "mystr[1]='a'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's move on discord until 12:35\n",
    "\n",
    "max 4 persons per room\n",
    "\n",
    "room 10 - quiet room (no max students limit)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "def change_n(mystr,n=2):\n",
    "    if len(mystr)<n or n<=0: # string too short or n<=0\n",
    "        return mystr\n",
    "    mylist=list(mystr)\n",
    "    mylist[n-1]='a' # changing the n-th element to 'a'\n",
    "    tmp='' # empty string\n",
    "    for k in mylist:\n",
    "        tmp+=k\n",
    "    return tmp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'force'"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "change_n('force',25)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'forca'"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "change_n('force',5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'farce'"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "change_n('force')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "def change_n(mystr,n=2): # string slicing\n",
    "    if len(mystr)<n or n<=0: # string too short or n<=0\n",
    "        return mystr\n",
    "    return mystr[:n-1]+'a'+mystr[n:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'carce'"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "change_n('corce')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'corae'"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "change_n('corce',4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## List comprehension"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "build  a list of the half of the first 10 integers [0,0.5,1,1.5,....]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n"
     ]
    }
   ],
   "source": [
    "mylist=[]\n",
    "for k in range(10):\n",
    "    mylist.append(k/2)\n",
    "print(mylist)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "more concise alternative "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n"
     ]
    }
   ],
   "source": [
    "mylist=[k/2 for k in range(10)] # list comprehension\n",
    "print(mylist)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can make more elaborate examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "mylist=[greeting+' deEar '+name for greeting in ['Hi','bye'] for name in ['Simone','Lucia','Rosella'] ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Hi dear Simone', 'Hi dear Lucia', 'Hi dear Rosella', 'bye dear Simone', 'bye dear Lucia', 'bye dear Rosella']\n"
     ]
    }
   ],
   "source": [
    "print(mylist)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's try to do the same with for loops"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['hi dear Simone', 'hi dear Lucia', 'hi dear Rosella', 'bye dear Simone', 'bye dear Lucia', 'bye dear Rosella']\n"
     ]
    }
   ],
   "source": [
    "mylist=[]\n",
    "for greeting in ['hi','bye']:\n",
    "    for name in ['Simone','Lucia','Rosella']:\n",
    "        mylist.append(greeting+' dear '+name)\n",
    "print(mylist)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`if`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 4, 16, 36, 64, 100]\n"
     ]
    }
   ],
   "source": [
    "myl=[k**2 for k in range(12) if k%2==0] # build a list of  squares of even numbers less than 12\n",
    "print(myl)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 4, 16, 36, 64, 100]\n"
     ]
    }
   ],
   "source": [
    "myl=[]\n",
    "for k in range(12):\n",
    "    if k%2==0:\n",
    "        myl.append(k**2)\n",
    "print(myl)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Note** on Quiz 4, Q5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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6GYWQ0GZz3bOLSg+3zmX7Zzb53u+CIgxs/pBTSoilcJVV11FdPT/9gZv27aNMWPGeJgofARylIsBqUCGc25iKWNO943DzDr43ndXMIOKSOXQvn17/u///q9wevDgwTz11FMeJgofgZz63wnoA3xjZum+14YDZwA4514FbgEGmVkesB/o5XSUv4gcpyeffJJvvvmGRx55hMsvv9zrOGHDvOrd+Ph4l5aW5slni4i3fvzxR0aPHs2ECROoUaOG13HCipmtdM75vcqYLs4lIhXGOUdKSgqPPPII2dnZVK9evcSNmuX46dR/EakwU6dOZcCAAWRnFxwoN2XKFL7++muPU0UOFbqIVJiEhAT+9Kc/FU4755g+fbqHiSKLCl1EKswpp5xCcnJy4fMpU6aQmprqcarIoX3oIhJ0zjl8RzKX0K1bN6ZMmUKPHj2Ii4ur2GARTlvoIhJU//73v7ngggtYvXp1qWPuv/9+lXk5UKGLSFDk5OQwbNgwLrnkEtLT0+nbty+5ublex6pUVOgiEhSff/45EydO5PDhwwCkp6czYcIEj1NVLip0EQmK6667jjvuuKPIa1u2bPEoTeWkQheRoJk8eTL169enWbNmfPjhh7zyyiteR6pUdJSLiByTnTt3UrduXapUqVJiXmxsLIsWLaJVq1Y6pd8D2kIXkYA455g9ezbnnHMOSUlJpY676KKLVOYeUaGLSJm2bdtGjx496N27N7t27eKJJ55g8+bNXseSYlToIlIm5xxffPFF4XROTg79+/dHV8kOLSp0ESlT48aNGT9+fOF01apV6datW+EhihIa9KOoiASkX79+zJ07l9zcXFJSUmjZsqXXkaQYFbqIFFqzZg2xsbE0atSoxDwzY/78+dSuXZuoKH25D0VaKyLCwYMHeeqpp4iPj2fw4MGl7huvW7euyjyEac2IVHI//vgj559/Ps8++yx5eXm89957vPPOO17HkuOgQhep5E4//XRq165d5LX77ruPvXv3epRIjpcKXaSSq1KlCqmpqZx00klAQcFPmzaNmjVrepxMjpV+FBURWrduzVNPPcXmzZsZN24cdevW9TqSHAcVukgl8e6773LyySdzzTXX+J0/YsSIUu8yJOFBhS4S4X755Rfuv/9+3nnnHRo3bsz69eupVatWiXEq8/BX5j50M2tqZv8yswwzW2dmD/oZY2Y2xcwyzew/ZnZB+cQVkWOxd+9e2rVrV3jUyo8//shjjz3mcSopL4H8KJoHDHPOtQI6AkPMrHWxMdcDLXyPAYAugiwSAmrWrEnfvn2LvDZjxgx++OEHjxJJeSqz0J1zPznnVvme7wUygMbFht0EzHIFlgF1zKxh0NOKyDEbOXIkZ599NgAXXnghK1as4IwzzvA4lZSHY9qHbmZxwPnA8mKzGgNbj5jO8r32U7E/P4CCLXj9DyVSQapXr05KSgrLli1j6NChREfrp7NIFfCaNbMawHzgIedcdvHZfv5IiXOHnXPTgekA8fHxuu6mSBDk5uYyYcIEsrOzee655/yOufzyy7n88ssrOJlUtIAK3cxiKCjz2c65BX6GZAFNj5huAmw78XgicjSrV68mMTGR1atXExUVxU033cTFF1/sdSzxSCBHuRiQCmQ45yaWMmwhcJfvaJeOwB7n3E+ljBWRIMjPz+e2225j9erVABw+fJjExEQOHTrkcTLxSiBHuXQC+gBXmlm673GDmQ00s4G+MYuATUAmkAwMLp+4IvKHKlWqlLi3588//0xGRoZHicRrZe5ycc79P/zvIz9yjAOGBCuUiATmmmuuISEhgddff51evXoxefJkGjRo4HUs8Yh+7hYJAzk5OZx88sl+502YMIGePXvSo0ePCk4loUZXWxQJYbt37yYhIYHOnTuTl5fnd8ypp56qMhdAhS4SsubPn0/r1q2ZOXMmK1euZOLE0o5JECmgQhcJUW+//Ta//PJL4fSoUaPYuHGjh4kk1KnQRULUSy+9xKmnnlo43bx5c/bv3+9hIgl1KnSREHXaaacxadIkYmJiGDVqFKtWreK8887zOpaEMB3lIuKh/Px81q1bR7t27fzO7927N5deeinNmzev4GQSjrSFLuKRjIwMOnfuTKdOndiyZYvfMWamMpeAqdBFPPDiiy/Svn17vvrqK/bt28fAgQMpOD9P5Pip0EU8UL169SLXXPnggw948803PUwkkUCFLuKBAQMG0Llz58LpHj16cOWVV3qYSCKBCl3EA1FRUaSkpNC0aVPmzp3Le++9R+PGxW8EJnJsVOgi5SQ7O5vk5ORS57do0YLvvvuOXr16UXCVapETo0IXKQeLFy+mbdu2DBgwgPnz55c6LiYmpgJTSaRToYsE2XPPPccNN9zA1q0Ft9kdMmQIu3fv9jiVVAYqdJEgu/HGG4tsef/yyy+MHTvWw0RSWajQRYKsbdu2DB8+HCj48fPRRx/l6aef9jaUVAo69V+kHDzxxBNs2LCBRx55hPj4eK/jSCWhLXSR47Bp0yb69OlDdna23/lVq1blrbfeUplLhdIWusgxyM/P56WXXmLEiBHk5ORQq1atEjdqFvGKttBFjkFSUhJDhw4lJycHgKlTp/LFF194nEqkgApd5Bj069ePs846q8hrb7zxhkdpRIpSoYscg5NPPpmUlBQAateuTWpqKtOmTfM4lUgB7UMX8SM/P58qVar4nXfFFVcwffp0unfvTqNGjSo4mUjpytxCN7MZZrbdzNaWMr+Lme0xs3TfY2TwY4pUnKVLl9KmTRtWrFhR6pj+/furzCXkBLLL5XXgujLGfOGca+97jD7xWCIVb8+ePQwcOJCuXbvy3//+l8TExCLXLBcJdWUWunPuc0AXopCIt2zZsiL7w7/55hv++te/ephI5NgE60fRS8xsjZktNrM2pQ0yswFmlmZmaTt27AjSR4sEx7XXXkufPn2KvKaLakk4sUDuY2hmccA/nXNt/cyrBRx2zu0zsxuAyc65FmW9Z3x8vEtLSzv2xCLlaNeuXbRq1Yo6deqQmprK5Zdf7nUkkSLMbKVzzu8pyCe8he6cy3bO7fM9XwTEmFn9E31fkfKybds28vPz/c6rV68eS5YsYc2aNSpzCTsnXOhmdrr5brdiZh1877nrRN9XJNgOHz7M9OnTadWqFZMnTy51XPv27alevXoFJhMJjjKPQzezuUAXoL6ZZQGjgBgA59yrwC3AIDPLA/YDvVwg+3FEKtAPP/zA3XffzdKlSwF48sknufHGG0uc9SkSzsosdOfcHWXMfxl4OWiJRMpBTEwM6enphdP79++nf//+fPrpp7qfp0QMnfovlULDhg158cUXC6dPOeUUevbsib5MSiTRqf9Sadx9993MmTMHgOnTpxMXF+dtIJEgU6FLRFm+fDmNGjWiadOmJeaZGfPnz6dGjRrazSIRSbtcJCL8/vvvPPzww1xyySUMGjSo1F0pNWvWVJlLxFKhS9jbunUr7dq148UXX8Q5x/vvv8/cuXO9jiVS4VToEvYaN25c4sqHDz74IHv37vUokYg3VOgS9qKiokhJSaFq1aoANGvWjNmzZ1OzZk2Pk4lULP0oKhGhZcuWjB49mqysLJ577jlq1KjhdSSRCqdCl7DgnGPOnDnUqVOH7t27+x3z2GOPVXAqkdCiQpeQt3XrVgYOHMiiRYs4/fTTWb9+PXXr1vU6lkjI0T50CWl79+6lffv2LFq0CICff/6ZRx991ONUIqFJhS4hrWbNmgwZMqTIa7NnzyYrK8ujRCKhS4UuIW/EiBG0atUKgMsuu4z09HSaNGnicSqR0KN96BLyqlatyowZM1i5ciWDBg0iKkrbISL+qNDFcwcPHuTZZ58lJyeHCRMm+B3TsWNHOnbsWMHJRMKLCl089fXXX5OYmEhGRgZmRs+ePenUqZPXsUTCkr67imfy8vK46667yMjIAAqONU9MTOTAgQMeJxMJTyp08Ux0dDTTpk0r8tqePXv49ttvPUokEt5U6OKpK6+8kv79+wOQmJjI+vXrOffccz1OJRKetA9dKkR2dja1atXyO2/cuHHcfvvtdOvWrYJTiUQWbaFLufr555+59dZb6dy5M7m5uX7H1K5dW2UuEgQqdCk3s2bNonXr1sybN481a9Ywbtw4ryOJRDQVupSbDz/8kF9//bVw+plnnmHDhg0eJhKJbCp0KTeTJk2ifv36hdPnnntuqff6FJETV2ahm9kMM9tuZmtLmW9mNsXMMs3sP2Z2QfBjSjiKjY1lypQpVKtWjRdeeIFly5YVXpNFRIIvkC3014HrjjL/eqCF7zEAeOXEY0m4yM3NZcWKFaXO79WrF99++y2PPvoo0dE6qEqkPJVZ6M65z4HdRxlyEzDLFVgG1DGzhsEKKKFr9erVXHzxxXTp0oXvv//e7xgz05URRSpIMPahNwa2HjGd5XutBDMbYGZpZpa2Y8eOIHy0eOX555/noosuYvXq1eTk5DBgwADtHxfxWDAK3fy85vdvtnNuunMu3jkXHxsbG4SPFq80aNCA/Pz8wumPP/6YmTNnephIRIJR6FlA0yOmmwDbgvC+EsL69u3LlVdeWTh9xx13lHrzZhGpGMEo9IXAXb6jXToCe5xzPwXhfSWEmRnJycm0aNGChQsXMmfOHPStS8RbZR52YGZzgS5AfTPLAkYBMQDOuVeBRcANQCaQA9xTXmGlYu3evZs33niDBx54ALOSe9bOPPNMMjIyqFKligfpRKS4MgvdOXdHGfMdMORoYyT8zJs3jyFDhrB9+3ZOO+00evXq5XecylwkdOhMUSnh6aef5tZbb2X79u0A3H///ezcudPjVCJSFhW6lHD77bdz0kknFU7v3LmT8ePHe5hIRAKhQpcSWrVqxciRIwGIiYnh6aefZvTo0R6nEpGy6Fxs8euxxx4jMzOTYcOG0bZtW6/jiEgAtIVeSWVkZHDzzTfz22+/+Z0fExPDa6+9pjIXCSMq9EomNzeXMWPG0L59exYsWMBjjz3mdSQRCRIVeiWTlJTEk08+yaFDhwBITk7m008/9TiViASDCr2SGThwIC1btizy2t///neP0ohIMKnQK5lq1aqRmpqKmREbG8tbb73FlClTvI4lIkGgo1wiVG5uLjExMX7nderUiZkzZ3L99dcXuUWciIQ3baFHoEWLFtGiRQuWLVtW6pg+ffqozEUijAo9guzcuZM+ffrQvXt3tmzZQt++fTl48KDXsUSkgqjQI0h6ejpvvvlm4XRGRgZjxozxMJGIVCQVegS56qqruOee/129OCoqisOHD3uYSEQqkn4UjTATJkxg8eLFxMbGMmPGDOLj472OJCIVRIUehjZv3kyTJk2Iji65+urWrcunn35K8+bNi1wxUUQin3a5hJH8/HwmTpxI69atmTBhQqnjWrVqpTIXqYRU6GHiu+++49JLL2XYsGHs37+fUaNGsXHjRq9jiUgIUaGHiZo1a5KZmVk4ffDgQRITE/Wjp4gUUqGHiQYNGjB58uTC6Tp16tC3b1+/N28WkcpJP4qGkTvvvJM5c+ZQrVo1kpKSaNiwodeRRCSEqNBDzNKlS4mLiyMuLq7EPDNj/vz5VKtWTVvmIlKCdrmEiD179nDvvffStWtX7r33XpxzfsdVr15dZS4ifqnQQ8CWLVto06YN06dPB2DJkiXMmjXL41QiEm4CKnQzu87M/mtmmWb2uJ/5CWa2w8zSfY9+wY8auZo2bUqLFi2KvDZs2DD27dvnUSIRCUdlFrqZVQGSgOuB1sAdZtbaz9C3nXPtfY+UIOeMaFFRUSQnJ1OtWjUAWrZsybvvvkuNGjU8TiYi4SSQH0U7AJnOuU0AZvYWcBOwvjyDVTZnnXUWzz//PNu3b2fkyJGF5S4iEqhACr0xsPWI6SzgYj/jbjazzsBGYKhzbmvxAWY2ABgAcMYZZxx72jB2+PBhUlJSiI2N5S9/+YvfMQ899FAFpxKRSBLIPnR/h1QUPwTjH0Ccc64d8DEw098bOeemO+finXPxsbGxx5Y0jGVmZtKtWzfuvfdeBg4cyK5du7yOJCIRKJBCzwKaHjHdBNh25ADn3C7n3B+3xkkGLgxOvPC3Z88e4uPjWbp0KQDbt29n6NCh3oYSkYgUSKGvAFqY2Z/M7CSgF7DwyAFmduQpizcCGcGLGN5q167Nww8/XOS1BQsWkJWV5VEiEYlUZRa6cy4PuA/4kIKi/ptzbp2ZjTazG33DHjCzdWa2BngASCivwOHo8ccf59xzzwXgmmuuYe3atTRp0sTjVCISaay0MxLLW3x8vEtLS/Pks8uLc67UszjT0tJYt24dd911l870FJHjZmYrnXN+b0Wma7kEwe+//85TTz3FoUOHePnll/2OiY+P1+3gRKRcqdBP0CeffEL//v35/vvvAbj11lu54oorPE4lIpWRruVyAvLy8hg8eHBhmQP069eP/fv3e5hKRCorFfoJiI6OJjk5uchrubm5bN682ZtAIlKpqdBPUOfOnRk0aBBmxgMPPMDatWtp1aqV17FEpBLSUS4BcM6xa9cu6tev73d+dnY269at45JLLqngZCJS2RztKBdtoZfhhx9+oHv37nTt2pVDhw75HVOrVi2VuYh4ToVeCuccU6dOpU2bNixevJi1a9fy/PPPex1LRKRUKvRSmBnLly8vcpOJMWPGsHbtWg9TiYiUToV+FBMnTqRBgwaF0x07dtR1ykUkZKnQj6JevXokJSVRo0YNpk6dytKlSznrrLO8jiUi4lelP1P0wIEDpKWlcdlll/mdf/PNN3PFFVdQma7fLiLhqVJvoX/11Vecf/75XH311WRmZvodY2YqcxEJC5W20EeNGsVll13Ghg0bOHDgAP369ePw4cNexxIROW6VttCbN2/OkSdVffbZZ7z++uveBRIROUGVttD79OnDtddeWzjdr18/evbs6WEiEZETU2kL3cyYNm0a7dq14+OPPyY5OZk6dep4HUtE5LhFdKH//PPPjB07ltKuV9OsWTPS09Pp1q1bBScTEQm+iDxs0TnHrFmzGDp0KL/++itNmjShd+/efsfqdnAiEikicgt9xIgRJCQk8OuvvwLw4IMPsn37do9TiYiUr4gs9ISEhCKn6O/evZvJkyd7mEhEpPxFZKGfffbZPPPMMwBUq1aN8ePHF06LiESqiNyHDvDwww+zZcsWhg4dquuviEilELZb6KtWreL6668v3E9eXHR0NElJSSpzEak0Aip0M7vOzP5rZplm9rif+VXN7G3f/OVmFhfsoH/Yv38/TzzxBB06dOCDDz5g2LBh5fVRIiJhpcxCN7MqQBJwPdAauMPMWhcblgj86pw7C3gR+Guwg/7h1VdfZezYseTn5wPw2muvsWTJkvL6OBGRsBHIFnoHINM5t8k5dwh4C7ip2JibgJm+5/OAblZOB3gPHjyY1q2L/nvy0UcflcdHiYiElUAKvTGw9YjpLN9rfsc45/KAPUC94m9kZgPMLM3M0nbs2HFcgatWrUpqaipmRuPGjVm4cCHjxo07rvcSEYkkgRzl4m9Lu/i59IGMwTk3HZgOEB8f7/98/AB07NiRv/3tb1x99dXUrl37eN9GRCSiBFLoWUDTI6abANtKGZNlZtFAbWB3UBKW4pZbbinPtxcRCTuB7HJZAbQwsz+Z2UlAL2BhsTELgbt9z28BPnWlXRFLRETKRZlb6M65PDO7D/gQqALMcM6tM7PRQJpzbiGQCrxhZpkUbJn3Ks/QIiJSUkBnijrnFgGLir028ojnB4BbgxtNRESORdieKSoiIkWp0EVEIoQKXUQkQqjQRUQihHl1dKGZ7QC2HOcfrw/sDGIcL2lZQlOkLEukLAdoWf7QzDkX62+GZ4V+IswszTkX73WOYNCyhKZIWZZIWQ7QsgRCu1xERCKECl1EJEKEa6FP9zpAEGlZQlOkLEukLAdoWcoUlvvQRUSkpHDdQhcRkWJU6CIiESKkCz2Ubk59ogJYlgQz22Fm6b5HPy9ylsXMZpjZdjNbW8p8M7MpvuX8j5ldUNEZAxXAsnQxsz1HrJOR/sZ5zcyamtm/zCzDzNaZ2YN+xoTFeglwWcJlvVQzs3+b2RrfsjzjZ0xwO8w5F5IPCi7V+x1wJnASsAZoXWzMYOBV3/NewNte5z6BZUkAXvY6awDL0hm4AFhbyvwbgMUU3MWqI7Dc68wnsCxdgH96nTOA5WgIXOB7XhPY6Of/r7BYLwEuS7isFwNq+J7HAMuBjsXGBLXDQnkLPaRuTn2CAlmWsOCc+5yj343qJmCWK7AMqGNmDSsm3bEJYFnCgnPuJ+fcKt/zvUAGJe/7GxbrJcBlCQu+/9b7fJMxvkfxo1CC2mGhXOhBuzl1CAhkWQBu9n0dnmdmTf3MDweBLmu4uMT3lXmxmbXxOkxZfF/Zz6dga/BIYbdejrIsECbrxcyqmFk6sB34yDlX6noJRoeFcqEH7ebUISCQnP8A4pxz7YCP+d+/2uEmXNZJIFZRcN2M84CXgHc9znNUZlYDmA885JzLLj7bzx8J2fVSxrKEzXpxzuU759pTcC/mDmbWttiQoK6XUC70Y7k5NRV1c+rjVOayOOd2OecO+iaTgQsrKFuwBbLewoJzLvuPr8yu4K5dMWZW3+NYfplZDAUFONs5t8DPkLBZL2UtSzitlz84534DlgLXFZsV1A4L5UKPpJtTl7ksxfZn3kjBvsNwtBC4y3dURUdgj3PuJ69DHQ8zO/2P/Zlm1oGCvwIheUQAAADOSURBVC+7vE1Vki9jKpDhnJtYyrCwWC+BLEsYrZdYM6vje14duArYUGxYUDssoHuKesFF0M2pA1yWB8zsRiCPgmVJ8CzwUZjZXAqOMqhvZlnAKAp+7ME59yoF9569AcgEcoB7vElatgCW5RZgkJnlAfuBXiG6wdAJ6AN849tfCzAcOAPCbr0Esizhsl4aAjPNrAoF/+j8zTn3z/LsMJ36LyISIUJ5l4uIiBwDFbqISIRQoYuIRAgVuohIhFChi4hECBW6iEiEUKGLiESI/w/4pu5R894kVwAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "x=range(4) # 4 elements\n",
    "#y=range(3) # 3 elements - not correct\n",
    "y=range(4) # fix\n",
    "plt.plot(x,y,'k:',linewidth=4)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cubicroot(n): # returns the cubic root of n\n",
    "    return pow(n,1/3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.0"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cubicroot(8)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Want to build a list, containing the cubic root of all integers from -20 to 20 included"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[(1.3572088082974534+2.350754612451197j), (1.3342008243609726+2.310903615293484j), (1.3103706971044484+2.269628624134352j), (1.2856407953291178+2.2267951777932917j), (1.2599210498948734+2.1822472719434427j), (1.2331060371652351+2.135802307490103j), (1.205071132087615+2.0872444275102944j), (1.1756673438603789+2.0363155723657256j), (1.144714242553332+1.982703228250094j), (1.1119900452846578+1.9260232559438435j), (1.0772173450159421+1.865795172362064j), (1.0400419115259523+1.8014054327640039j), (1.0000000000000002+1.7320508075688772j), (0.9564655913861947+1.656646999972302j), (0.9085602964160701+1.5736725951324722j), (0.8549879733383486+1.480882609682364j), (0.7937005259840999+1.3747296369986024j), (0.7211247851537043+1.2490247664834064j), (0.6299605249474367+1.0911236359717214j), (0.5000000000000001+0.8660254037844386j), 0.0, 1.0, 1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968, 1.8171205928321397, 1.912931182772389, 2.0, 2.080083823051904, 2.154434690031884, 2.2239800905693152, 2.2894284851066637, 2.3513346877207573, 2.4101422641752297, 2.46621207433047, 2.5198420997897464, 2.571281590658235, 2.6207413942088964, 2.668401648721945, 2.7144176165949063]\n"
     ]
    }
   ],
   "source": [
    "mylist=[cubicroot(k) for k in range(-20,21)]\n",
    "print(mylist)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Ex.** plot $x^3-2x+1$ in [0,1] (using 'a lot of steps'[say at least 100])\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* build `xcoord` list\n",
    "* build `ycoord` list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n"
     ]
    }
   ],
   "source": [
    "n=10 # number of steps\n",
    "xcoord=[x/n for x in range(n+1)] # step-wise description of [0,1] with n equal steps\n",
    "print(xcoord)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "n=1000\n",
    "xcoord=[x/n for x in range(n+1)] # step-wise description of [0,1] with n equal steps\n",
    "ycoord=[x**3 - 2*x + 1 for x in xcoord]\n",
    "\n",
    "plt.plot(xcoord,ycoord)\n",
    "plt.show()\n",
    "#print(ycoord)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Ex.** plot the graph of the circle with radius 2 centered at the origin\n",
    "\n",
    "Use the parametrization $x=\\cos(t),\\quad y=\\sin(t)$ for $t\\in[0,2\\pi)$\n",
    "\n",
    "Once you have the plot (use at least 100 steps)\n",
    "1. put your name as the plot title\n",
    "2. upload on discord in the channel - circle"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "to keep the same scale use `plt.axis('equal')`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Project 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## step 1:\n",
    "\n",
    "1. find a way to generate k areas (using the p-series) (say k=100,p=2)\n",
    "2. find a way to generate the corresponding radii\n",
    "3. find area of black circle (for a p-series we need the $\\zeta$ function\n",
    "`from scipy.special import zetac`\n",
    "\n",
    "$\\sum_{n=1}^\\infty \\dfrac{1}{n^p}=1+\\dfrac{1}{4}+\\dfrac{1}{9}+\\ldots=A_1+A_2+A_3+\\ldots$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "from math import pi, sqrt\n",
    "k=100\n",
    "p=2\n",
    "A=[(1/n**p) for n in range(1,k+1)] # list of the areas of the small circles\n",
    "r=[sqrt(a/pi) for a in A] # list of radii of small circles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.0, 0.25, 0.1111111111111111]\n"
     ]
    }
   ],
   "source": [
    "print(A[:3])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.5641895835477563, 0.28209479177387814, 0.18806319451591877]\n"
     ]
    }
   ],
   "source": [
    "print(r[:3])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.6449340668482264"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from scipy.special import zetac\n",
    "\n",
    "\n",
    "zetac(2) # this sums the term from 2 to infty"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.6449340668482264\n"
     ]
    }
   ],
   "source": [
    "A_bc=1+zetac(2) # area of big circle for p=2 corresponding to the sum of the series\n",
    "print(A_bc)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Ex.** build a function `find_radii_p(k,p)` that will compute (and return) the radii of the first k small circles and the radius of the big circle for the p-series\n",
    "\n",
    "**Ex.** build a function `find_radii_g(k,p)` that will compute (and return) the radii of the first k small circles and the radius of the big circle for the geometric series"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
